<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReactiveLdaptiveTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Integration Ldaptive</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.ldaptive.reactive</a> &gt; <span class="el_source">ReactiveLdaptiveTemplate.java</span></div><h1>ReactiveLdaptiveTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.ldaptive.reactive;

import static org.ldaptive.handler.ResultPredicate.NOT_SUCCESS;

import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.bremersee.exception.ServiceException;
import org.bremersee.ldaptive.DefaultLdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveEntryMapper;
import org.bremersee.ldaptive.LdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveTemplate;
import org.ldaptive.AddOperation;
import org.ldaptive.AddRequest;
import org.ldaptive.AttributeModification;
import org.ldaptive.BindRequest;
import org.ldaptive.CompareOperation;
import org.ldaptive.CompareRequest;
import org.ldaptive.ConnectionFactory;
import org.ldaptive.DeleteOperation;
import org.ldaptive.DeleteRequest;
import org.ldaptive.LdapAttribute;
import org.ldaptive.LdapEntry;
import org.ldaptive.LdapException;
import org.ldaptive.ModifyDnOperation;
import org.ldaptive.ModifyDnRequest;
import org.ldaptive.ModifyOperation;
import org.ldaptive.ModifyRequest;
import org.ldaptive.Result;
import org.ldaptive.ResultCode;
import org.ldaptive.SearchOperation;
import org.ldaptive.SearchRequest;
import org.ldaptive.extended.ExtendedOperation;
import org.ldaptive.extended.ExtendedRequest;
import org.ldaptive.extended.ExtendedResponse;
import org.ldaptive.handler.ResultHandler;
import org.ldaptive.handler.ResultPredicate;
import reactor.core.publisher.Flux;
import reactor.core.publisher.FluxSink;
import reactor.core.publisher.Mono;

/**
 * The reactive ldaptive template.
 *
 * @author Christian Bremer
 */
public class ReactiveLdaptiveTemplate implements ReactiveLdaptiveOperations {

<span class="fc" id="L67">  private static final Log log = LogFactory.getLog(ReactiveLdaptiveTemplate.class);</span>

<span class="pc bpc" id="L69" title="1 of 2 branches missed.">  private static final ResultPredicate NOT_COMPARE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_TRUE</span>
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_FALSE;</span>

<span class="fc bfc" id="L73" title="All 2 branches covered.">  private static final ResultPredicate NOT_DELETE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.NO_SUCH_OBJECT;</span>

<span class="fc" id="L76">  private static final ResultPredicate NOT_FIND_RESULT = NOT_DELETE_RESULT;</span>

  private final ConnectionFactory connectionFactory;

<span class="fc" id="L80">  private LdaptiveErrorHandler errorHandler = new DefaultLdaptiveErrorHandler();</span>

  /**
   * Instantiates a new Reactive ldaptive template.
   *
   * @param connectionFactory the connection factory
   */
<span class="fc" id="L87">  public ReactiveLdaptiveTemplate(ConnectionFactory connectionFactory) {</span>
<span class="fc" id="L88">    this.connectionFactory = connectionFactory;</span>
<span class="fc" id="L89">  }</span>

  @Override
  public ConnectionFactory getConnectionFactory() {
<span class="fc" id="L93">    return connectionFactory;</span>
  }

  /**
   * Sets error handler.
   *
   * @param errorHandler the error handler
   */
  public void setErrorHandler(LdaptiveErrorHandler errorHandler) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">    if (errorHandler != null) {</span>
<span class="fc" id="L103">      this.errorHandler = errorHandler;</span>
    }
<span class="fc" id="L105">  }</span>

  @Override
  public ReactiveLdaptiveTemplate copy() {
<span class="fc" id="L109">    return copy(null);</span>
  }

  @Override
  public ReactiveLdaptiveTemplate copy(final LdaptiveErrorHandler errorHandler) {
<span class="fc" id="L114">    final ReactiveLdaptiveTemplate template = new ReactiveLdaptiveTemplate(connectionFactory);</span>
<span class="fc" id="L115">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L116">    return template;</span>
  }

  @Override
  public Mono&lt;Result&gt; add(AddRequest addRequest) {
<span class="fc" id="L121">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L123">      AddOperation.builder()</span>
<span class="fc" id="L124">          .factory(connectionFactory)</span>
<span class="fc" id="L125">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="pc" id="L126">          .onException(ldapException -&gt; future</span>
<span class="nc" id="L127">              .completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L128">          .build()</span>
<span class="fc" id="L129">          .send(addRequest);</span>

<span class="nc" id="L131">    } catch (LdapException e) {</span>
<span class="nc" id="L132">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L133">    }</span>
<span class="fc" id="L134">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; add(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L138">    String[] objectClasses = entryMapper.getObjectClasses();</span>
<span class="pc bpc" id="L139" title="2 of 4 branches missed.">    if (objectClasses == null || objectClasses.length == 0) {</span>
<span class="nc" id="L140">      final ServiceException se = ServiceException.internalServerError(</span>
          &quot;Object classes must be specified to save a new ldap entry.&quot;,
          &quot;org.bremersee:ldaptive-integration:d7aa5699-fd2e-45df-a863-97960e8095b8&quot;);
<span class="nc" id="L143">      log.error(&quot;Saving domain object failed.&quot;, se);</span>
<span class="nc" id="L144">      throw se;</span>
    }
<span class="fc" id="L146">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L147">    LdapEntry entry = new LdapEntry();</span>
<span class="fc" id="L148">    entryMapper.map(domainObject, entry);</span>
<span class="fc" id="L149">    entry.setDn(dn);</span>
<span class="fc" id="L150">    entry.addAttributes(new LdapAttribute(&quot;objectclass&quot;, objectClasses));</span>
<span class="fc" id="L151">    return add(new AddRequest(dn, entry.getAttributes()))</span>
<span class="fc" id="L152">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; bind(BindRequest bindRequest) {
    // Bind requests are synchronous
<span class="fc" id="L158">    LdaptiveTemplate template = new LdaptiveTemplate(getConnectionFactory());</span>
<span class="fc" id="L159">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L160">    return Mono.just(template.bind(bindRequest));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; compare(CompareRequest compareRequest) {
<span class="fc" id="L165">    CompletableFuture&lt;Boolean&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L167">      CompareOperation.builder()</span>
<span class="fc" id="L168">          .factory(connectionFactory)</span>
<span class="fc" id="L169">          .onCompare(</span>
<span class="fc" id="L170">              future::complete) // this will be only called, if the result is COMPARE_TRUE or COMPARE_FALSE</span>
<span class="fc" id="L171">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_COMPARE_RESULT, errorHandler,</span>
              Result::isSuccess))
<span class="fc" id="L173">          .onException(</span>
<span class="nc" id="L174">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L175">          .build()</span>
<span class="fc" id="L176">          .send(compareRequest);</span>

<span class="nc" id="L178">    } catch (LdapException e) {</span>
<span class="nc" id="L179">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L180">    }</span>
<span class="fc" id="L181">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; delete(DeleteRequest deleteRequest) {
<span class="fc" id="L186">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L188">      DeleteOperation.builder()</span>
<span class="fc" id="L189">          .factory(connectionFactory)</span>
<span class="fc" id="L190">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_DELETE_RESULT, errorHandler, r -&gt; r))</span>
<span class="fc" id="L191">          .onException(</span>
<span class="nc" id="L192">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L193">          .build()</span>
<span class="fc" id="L194">          .send(deleteRequest)</span>
<span class="fc" id="L195">          .await();</span>

<span class="nc" id="L197">    } catch (LdapException e) {</span>
<span class="nc" id="L198">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L199">    }</span>
<span class="fc" id="L200">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;ExtendedResponse&gt; executeExtension(ExtendedRequest request) {

<span class="fc" id="L206">    CompletableFuture&lt;ExtendedResponse&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L208">      ExtendedOperation.builder()</span>
<span class="fc" id="L209">          .factory(connectionFactory)</span>
<span class="fc" id="L210">          .onExtended((name, value) -&gt; future.complete(ExtendedResponse.builder()</span>
<span class="fc" id="L211">              .responseName(name)</span>
<span class="fc" id="L212">              .responseValue(value)</span>
<span class="fc" id="L213">              .resultCode(ResultCode.SUCCESS)</span>
<span class="fc" id="L214">              .build()))</span>
<span class="fc" id="L215">          .onResult(new FutureAwareResultHandler&lt;&gt;(</span>
              future,
              NOT_SUCCESS,
              errorHandler,
<span class="nc" id="L219">              r -&gt; ExtendedResponse.builder().resultCode(r.getResultCode()).build()))</span>
<span class="fc" id="L220">          .onException(</span>
<span class="nc" id="L221">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L222">          .build()</span>
<span class="fc" id="L223">          .send(request);</span>

<span class="nc" id="L225">    } catch (LdapException e) {</span>
<span class="nc" id="L226">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L227">    }</span>
<span class="fc" id="L228">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; modify(ModifyRequest modifyRequest) {
<span class="fc" id="L233">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L235">      ModifyOperation.builder()</span>
<span class="fc" id="L236">          .factory(connectionFactory)</span>
<span class="fc" id="L237">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L238">          .onException(</span>
<span class="nc" id="L239">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L240">          .build()</span>
<span class="fc" id="L241">          .send(modifyRequest);</span>

<span class="nc" id="L243">    } catch (LdapException e) {</span>
<span class="nc" id="L244">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L245">    }</span>
<span class="fc" id="L246">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; modify(T domainObject, LdapEntry entry, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L250">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L251">    AttributeModification[] modifications = entryMapper.mapAndComputeModifications(domainObject,</span>
        entry);
<span class="fc" id="L253">    return modify(new ModifyRequest(dn, modifications))</span>
<span class="fc" id="L254">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Result&gt; modifyDn(ModifyDnRequest modifyDnRequest) {
<span class="fc" id="L259">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L261">      ModifyDnOperation.builder()</span>
<span class="fc" id="L262">          .factory(connectionFactory)</span>
<span class="fc" id="L263">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L264">          .onException(</span>
<span class="nc" id="L265">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L266">          .build()</span>
<span class="fc" id="L267">          .send(modifyDnRequest);</span>

<span class="nc" id="L269">    } catch (LdapException e) {</span>
<span class="nc" id="L270">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L271">    }</span>
<span class="fc" id="L272">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;LdapEntry&gt; findOne(SearchRequest searchRequest) {
<span class="fc" id="L277">    CompletableFuture&lt;LdapEntry&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L279">      SearchOperation.builder()</span>
<span class="fc" id="L280">          .factory(connectionFactory)</span>
<span class="fc" id="L281">          .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L282">            future.complete(ldapEntry);</span>
<span class="fc" id="L283">            return ldapEntry;</span>
          })
<span class="fc" id="L285">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_FIND_RESULT, errorHandler, null))</span>
<span class="pc" id="L286">          .onException(ldapException -&gt; future.obtrudeException(errorHandler.map(ldapException)))</span>
<span class="fc" id="L287">          .build()</span>
<span class="fc" id="L288">          .send(searchRequest);</span>

<span class="nc" id="L290">    } catch (LdapException e) {</span>
<span class="nc" id="L291">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L292">    }</span>
<span class="fc" id="L293">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Flux&lt;LdapEntry&gt; findAll(SearchRequest searchRequest) {
<span class="fc" id="L298">    return Flux.create((FluxSink&lt;LdapEntry&gt; fluxSink) -&gt; {</span>
      try {
<span class="fc" id="L300">        SearchOperation.builder()</span>
<span class="fc" id="L301">            .factory(connectionFactory)</span>
<span class="fc" id="L302">            .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L303">              fluxSink.next(ldapEntry);</span>
<span class="fc" id="L304">              return ldapEntry;</span>
            })
<span class="fc" id="L306">            .onResult(new FluxSinkAwareResultHandler&lt;&gt;(fluxSink, NOT_FIND_RESULT, errorHandler))</span>
<span class="pc" id="L307">            .onException(ldapException -&gt; fluxSink.error(errorHandler.map(ldapException)))</span>
<span class="fc" id="L308">            .build()</span>
<span class="fc" id="L309">            .send(searchRequest);</span>

<span class="nc" id="L311">      } catch (LdapException e) {</span>
<span class="nc" id="L312">        fluxSink.error(errorHandler.map(e));</span>
<span class="fc" id="L313">      }</span>
<span class="fc" id="L314">    });</span>
  }

  @Override
  public &lt;T&gt; Mono&lt;T&gt; save(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L319">    return findOne(SearchRequest.objectScopeSearchRequest(entryMapper.mapDn(domainObject)))</span>
<span class="fc" id="L320">        .flatMap(entry -&gt; modify(domainObject, entry, entryMapper))</span>
<span class="fc" id="L321">        .switchIfEmpty(add(domainObject, entryMapper));</span>
  }

  private static class FutureAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final CompletableFuture&lt;T&gt; future;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    private final Function&lt;Result, T&gt; resultValueFn;

    /**
     * Instantiates a new Future aware result handler.
     *
     * @param future the future
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     * @param resultValueFn the result value fn
     */
    public FutureAwareResultHandler(
        CompletableFuture&lt;T&gt; future,
        ResultPredicate throwErrorPredicate,
        LdaptiveErrorHandler errorHandler,
<span class="fc" id="L346">        Function&lt;Result, T&gt; resultValueFn) {</span>
<span class="fc" id="L347">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L348">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L349">      this.future = future;</span>
<span class="fc" id="L350">      this.resultValueFn = resultValueFn;</span>
<span class="fc" id="L351">    }</span>

    @Override
    public void accept(Result result) {
<span class="fc bfc" id="L355" title="All 2 branches covered.">      if (!future.isDone()) {</span>
<span class="pc bpc" id="L356" title="1 of 4 branches missed.">        if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="fc" id="L357">          future.completeExceptionally(errorHandler.map(new LdapException(result)));</span>
        } else {
<span class="fc bfc" id="L359" title="All 2 branches covered.">          future.complete(resultValueFn != null ? resultValueFn.apply(result) : null);</span>
        }
      }
<span class="fc" id="L362">    }</span>
  }

  private static class FluxSinkAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final FluxSink&lt;T&gt; fluxSink;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    /**
     * Instantiates a new Flux sink aware result handler.
     *
     * @param fluxSink the flux sink
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     */
    public FluxSinkAwareResultHandler(
        FluxSink&lt;T&gt; fluxSink,
        ResultPredicate throwErrorPredicate,
<span class="fc" id="L383">        LdaptiveErrorHandler errorHandler) {</span>
<span class="fc" id="L384">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L385">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L386">      this.fluxSink = fluxSink;</span>
<span class="fc" id="L387">    }</span>

    @Override
    public void accept(Result result) {
<span class="pc bpc" id="L391" title="2 of 4 branches missed.">      if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="nc" id="L392">        fluxSink.error(errorHandler.map(new LdapException(result)));</span>
      } else {
<span class="fc" id="L394">        fluxSink.complete();</span>
      }
<span class="fc" id="L396">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>