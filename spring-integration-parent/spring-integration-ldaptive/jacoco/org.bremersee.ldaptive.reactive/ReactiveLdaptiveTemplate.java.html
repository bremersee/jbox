<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReactiveLdaptiveTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Integration Ldaptive</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.ldaptive.reactive</a> &gt; <span class="el_source">ReactiveLdaptiveTemplate.java</span></div><h1>ReactiveLdaptiveTemplate.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.ldaptive.reactive;

import static org.ldaptive.handler.ResultPredicate.NOT_SUCCESS;

import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Function;
import lombok.extern.slf4j.Slf4j;
import org.bremersee.exception.ServiceException;
import org.bremersee.ldaptive.DefaultLdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveEntryMapper;
import org.bremersee.ldaptive.LdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveTemplate;
import org.ldaptive.AddOperation;
import org.ldaptive.AddRequest;
import org.ldaptive.AttributeModification;
import org.ldaptive.BindRequest;
import org.ldaptive.CompareOperation;
import org.ldaptive.CompareRequest;
import org.ldaptive.ConnectionFactory;
import org.ldaptive.DeleteOperation;
import org.ldaptive.DeleteRequest;
import org.ldaptive.LdapAttribute;
import org.ldaptive.LdapEntry;
import org.ldaptive.LdapException;
import org.ldaptive.ModifyDnOperation;
import org.ldaptive.ModifyDnRequest;
import org.ldaptive.ModifyOperation;
import org.ldaptive.ModifyRequest;
import org.ldaptive.Result;
import org.ldaptive.ResultCode;
import org.ldaptive.SearchOperation;
import org.ldaptive.SearchRequest;
import org.ldaptive.extended.ExtendedOperation;
import org.ldaptive.extended.ExtendedRequest;
import org.ldaptive.extended.ExtendedResponse;
import org.ldaptive.handler.ResultHandler;
import org.ldaptive.handler.ResultPredicate;
import reactor.core.publisher.Flux;
import reactor.core.publisher.FluxSink;
import reactor.core.publisher.Mono;

/**
 * The reactive ldaptive template.
 *
 * @author Christian Bremer
 */
<span class="fc" id="L64">@Slf4j</span>
public class ReactiveLdaptiveTemplate implements ReactiveLdaptiveOperations {

<span class="pc bpc" id="L67" title="1 of 2 branches missed.">  private static final ResultPredicate NOT_COMPARE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_TRUE</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.COMPARE_FALSE;</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">  private static final ResultPredicate NOT_DELETE_RESULT = result -&gt; !result.isSuccess()</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">      &amp;&amp; result.getResultCode() != ResultCode.NO_SUCH_OBJECT;</span>

<span class="fc" id="L74">  private static final ResultPredicate NOT_FIND_RESULT = NOT_DELETE_RESULT;</span>

  private final ConnectionFactory connectionFactory;

<span class="fc" id="L78">  private LdaptiveErrorHandler errorHandler = new DefaultLdaptiveErrorHandler();</span>

  /**
   * Instantiates a new Reactive ldaptive template.
   *
   * @param connectionFactory the connection factory
   */
<span class="fc" id="L85">  public ReactiveLdaptiveTemplate(ConnectionFactory connectionFactory) {</span>
<span class="fc" id="L86">    this.connectionFactory = connectionFactory;</span>
<span class="fc" id="L87">  }</span>

  @Override
  public ConnectionFactory getConnectionFactory() {
<span class="fc" id="L91">    return connectionFactory;</span>
  }

  /**
   * Sets error handler.
   *
   * @param errorHandler the error handler
   */
  public void setErrorHandler(LdaptiveErrorHandler errorHandler) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">    if (errorHandler != null) {</span>
<span class="fc" id="L101">      this.errorHandler = errorHandler;</span>
    }
<span class="fc" id="L103">  }</span>

  @Override
  public ReactiveLdaptiveTemplate copy() {
<span class="fc" id="L107">    return copy(null);</span>
  }

  @Override
  public ReactiveLdaptiveTemplate copy(final LdaptiveErrorHandler errorHandler) {
<span class="fc" id="L112">    final ReactiveLdaptiveTemplate template = new ReactiveLdaptiveTemplate(connectionFactory);</span>
<span class="fc" id="L113">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L114">    return template;</span>
  }

  @Override
  public Mono&lt;Result&gt; add(AddRequest addRequest) {
<span class="fc" id="L119">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L121">      AddOperation.builder()</span>
<span class="fc" id="L122">          .factory(connectionFactory)</span>
<span class="fc" id="L123">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="pc" id="L124">          .onException(ldapException -&gt; future</span>
<span class="nc" id="L125">              .completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L126">          .build()</span>
<span class="fc" id="L127">          .send(addRequest);</span>

<span class="nc" id="L129">    } catch (LdapException e) {</span>
<span class="nc" id="L130">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L131">    }</span>
<span class="fc" id="L132">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; add(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L136">    String[] objectClasses = entryMapper.getObjectClasses();</span>
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">    if (objectClasses == null || objectClasses.length == 0) {</span>
<span class="nc" id="L138">      final ServiceException se = ServiceException.internalServerError(</span>
          &quot;Object classes must be specified to save a new ldap entry.&quot;,
          &quot;org.bremersee:ldaptive-integration:d7aa5699-fd2e-45df-a863-97960e8095b8&quot;);
<span class="nc" id="L141">      log.error(&quot;Saving domain object failed.&quot;, se);</span>
<span class="nc" id="L142">      throw se;</span>
    }
<span class="fc" id="L144">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L145">    LdapEntry entry = new LdapEntry();</span>
<span class="fc" id="L146">    entryMapper.map(domainObject, entry);</span>
<span class="fc" id="L147">    entry.setDn(dn);</span>
<span class="fc" id="L148">    entry.addAttributes(new LdapAttribute(&quot;objectclass&quot;, objectClasses));</span>
<span class="fc" id="L149">    return add(new AddRequest(dn, entry.getAttributes()))</span>
<span class="fc" id="L150">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; bind(BindRequest bindRequest) {
    // Bind requests are synchronous
<span class="fc" id="L156">    LdaptiveTemplate template = new LdaptiveTemplate(getConnectionFactory());</span>
<span class="fc" id="L157">    template.setErrorHandler(errorHandler);</span>
<span class="fc" id="L158">    return Mono.just(template.bind(bindRequest));</span>
  }

  @Override
  public Mono&lt;Boolean&gt; compare(CompareRequest compareRequest) {
<span class="fc" id="L163">    CompletableFuture&lt;Boolean&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L165">      CompareOperation.builder()</span>
<span class="fc" id="L166">          .factory(connectionFactory)</span>
<span class="fc" id="L167">          .onCompare(</span>
<span class="fc" id="L168">              future::complete) // this will be only called, if the result is COMPARE_TRUE or COMPARE_FALSE</span>
<span class="fc" id="L169">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_COMPARE_RESULT, errorHandler,</span>
              Result::isSuccess))
<span class="fc" id="L171">          .onException(</span>
<span class="nc" id="L172">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L173">          .build()</span>
<span class="fc" id="L174">          .send(compareRequest);</span>

<span class="nc" id="L176">    } catch (LdapException e) {</span>
<span class="nc" id="L177">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L178">    }</span>
<span class="fc" id="L179">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; delete(DeleteRequest deleteRequest) {
<span class="fc" id="L184">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L186">      DeleteOperation.builder()</span>
<span class="fc" id="L187">          .factory(connectionFactory)</span>
<span class="fc" id="L188">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_DELETE_RESULT, errorHandler, r -&gt; r))</span>
<span class="fc" id="L189">          .onException(</span>
<span class="nc" id="L190">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L191">          .build()</span>
<span class="fc" id="L192">          .send(deleteRequest)</span>
<span class="fc" id="L193">          .await();</span>

<span class="nc" id="L195">    } catch (LdapException e) {</span>
<span class="nc" id="L196">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L197">    }</span>
<span class="fc" id="L198">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;ExtendedResponse&gt; executeExtension(ExtendedRequest request) {

<span class="fc" id="L204">    CompletableFuture&lt;ExtendedResponse&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L206">      ExtendedOperation.builder()</span>
<span class="fc" id="L207">          .factory(connectionFactory)</span>
<span class="fc" id="L208">          .onExtended((name, value) -&gt; future.complete(ExtendedResponse.builder()</span>
<span class="fc" id="L209">              .responseName(name)</span>
<span class="fc" id="L210">              .responseValue(value)</span>
<span class="fc" id="L211">              .resultCode(ResultCode.SUCCESS)</span>
<span class="fc" id="L212">              .build()))</span>
<span class="fc" id="L213">          .onResult(new FutureAwareResultHandler&lt;&gt;(</span>
              future,
              NOT_SUCCESS,
              errorHandler,
<span class="nc" id="L217">              r -&gt; ExtendedResponse.builder().resultCode(r.getResultCode()).build()))</span>
<span class="fc" id="L218">          .onException(</span>
<span class="nc" id="L219">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L220">          .build()</span>
<span class="fc" id="L221">          .send(request);</span>

<span class="nc" id="L223">    } catch (LdapException e) {</span>
<span class="nc" id="L224">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L225">    }</span>
<span class="fc" id="L226">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;Result&gt; modify(ModifyRequest modifyRequest) {
<span class="fc" id="L231">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L233">      ModifyOperation.builder()</span>
<span class="fc" id="L234">          .factory(connectionFactory)</span>
<span class="fc" id="L235">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L236">          .onException(</span>
<span class="nc" id="L237">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L238">          .build()</span>
<span class="fc" id="L239">          .send(modifyRequest);</span>

<span class="nc" id="L241">    } catch (LdapException e) {</span>
<span class="nc" id="L242">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L243">    }</span>
<span class="fc" id="L244">    return Mono.fromFuture(future);</span>
  }

  private &lt;T&gt; Mono&lt;T&gt; modify(T domainObject, LdapEntry entry, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L248">    String dn = entryMapper.mapDn(domainObject);</span>
<span class="fc" id="L249">    AttributeModification[] modifications = entryMapper.mapAndComputeModifications(domainObject,</span>
        entry);
<span class="fc" id="L251">    return modify(new ModifyRequest(dn, modifications))</span>
<span class="fc" id="L252">        .then(Mono.just(Objects.requireNonNull(entryMapper.map(entry))));</span>
  }

  @Override
  public Mono&lt;Result&gt; modifyDn(ModifyDnRequest modifyDnRequest) {
<span class="fc" id="L257">    CompletableFuture&lt;Result&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L259">      ModifyDnOperation.builder()</span>
<span class="fc" id="L260">          .factory(connectionFactory)</span>
<span class="fc" id="L261">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_SUCCESS, errorHandler, r -&gt; r))</span>
<span class="fc" id="L262">          .onException(</span>
<span class="nc" id="L263">              ldapException -&gt; future.completeExceptionally(errorHandler.map(ldapException)))</span>
<span class="fc" id="L264">          .build()</span>
<span class="fc" id="L265">          .send(modifyDnRequest);</span>

<span class="nc" id="L267">    } catch (LdapException e) {</span>
<span class="nc" id="L268">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L269">    }</span>
<span class="fc" id="L270">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Mono&lt;LdapEntry&gt; findOne(SearchRequest searchRequest) {
<span class="fc" id="L275">    CompletableFuture&lt;LdapEntry&gt; future = new CompletableFuture&lt;&gt;();</span>
    try {
<span class="fc" id="L277">      SearchOperation.builder()</span>
<span class="fc" id="L278">          .factory(connectionFactory)</span>
<span class="fc" id="L279">          .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L280">            future.complete(ldapEntry);</span>
<span class="fc" id="L281">            return ldapEntry;</span>
          })
<span class="fc" id="L283">          .onResult(new FutureAwareResultHandler&lt;&gt;(future, NOT_FIND_RESULT, errorHandler, null))</span>
<span class="pc" id="L284">          .onException(ldapException -&gt; future.obtrudeException(errorHandler.map(ldapException)))</span>
<span class="fc" id="L285">          .build()</span>
<span class="fc" id="L286">          .send(searchRequest);</span>

<span class="nc" id="L288">    } catch (LdapException e) {</span>
<span class="nc" id="L289">      future.completeExceptionally(errorHandler.map(e));</span>
<span class="fc" id="L290">    }</span>
<span class="fc" id="L291">    return Mono.fromFuture(future);</span>
  }

  @Override
  public Flux&lt;LdapEntry&gt; findAll(SearchRequest searchRequest) {
<span class="fc" id="L296">    return Flux.create((FluxSink&lt;LdapEntry&gt; fluxSink) -&gt; {</span>
      try {
<span class="fc" id="L298">        SearchOperation.builder()</span>
<span class="fc" id="L299">            .factory(connectionFactory)</span>
<span class="fc" id="L300">            .onEntry(ldapEntry -&gt; {</span>
<span class="fc" id="L301">              fluxSink.next(ldapEntry);</span>
<span class="fc" id="L302">              return ldapEntry;</span>
            })
<span class="fc" id="L304">            .onResult(new FluxSinkAwareResultHandler&lt;&gt;(fluxSink, NOT_FIND_RESULT, errorHandler))</span>
<span class="pc" id="L305">            .onException(ldapException -&gt; fluxSink.error(errorHandler.map(ldapException)))</span>
<span class="fc" id="L306">            .build()</span>
<span class="fc" id="L307">            .send(searchRequest);</span>

<span class="nc" id="L309">      } catch (LdapException e) {</span>
<span class="nc" id="L310">        fluxSink.error(errorHandler.map(e));</span>
<span class="fc" id="L311">      }</span>
<span class="fc" id="L312">    });</span>
  }

  @Override
  public &lt;T&gt; Mono&lt;T&gt; save(T domainObject, LdaptiveEntryMapper&lt;T&gt; entryMapper) {
<span class="fc" id="L317">    return findOne(SearchRequest.objectScopeSearchRequest(entryMapper.mapDn(domainObject)))</span>
<span class="fc" id="L318">        .flatMap(entry -&gt; modify(domainObject, entry, entryMapper))</span>
<span class="fc" id="L319">        .switchIfEmpty(add(domainObject, entryMapper));</span>
  }

  private static class FutureAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final CompletableFuture&lt;T&gt; future;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    private final Function&lt;Result, T&gt; resultValueFn;

    /**
     * Instantiates a new Future aware result handler.
     *
     * @param future the future
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     * @param resultValueFn the result value fn
     */
    public FutureAwareResultHandler(
        CompletableFuture&lt;T&gt; future,
        ResultPredicate throwErrorPredicate,
        LdaptiveErrorHandler errorHandler,
<span class="fc" id="L344">        Function&lt;Result, T&gt; resultValueFn) {</span>
<span class="fc" id="L345">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L346">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L347">      this.future = future;</span>
<span class="fc" id="L348">      this.resultValueFn = resultValueFn;</span>
<span class="fc" id="L349">    }</span>

    @Override
    public void accept(Result result) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (!future.isDone()) {</span>
<span class="pc bpc" id="L354" title="1 of 4 branches missed.">        if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="fc" id="L355">          future.completeExceptionally(errorHandler.map(new LdapException(result)));</span>
        } else {
<span class="fc bfc" id="L357" title="All 2 branches covered.">          future.complete(resultValueFn != null ? resultValueFn.apply(result) : null);</span>
        }
      }
<span class="fc" id="L360">    }</span>
  }

  private static class FluxSinkAwareResultHandler&lt;T&gt; implements ResultHandler {

    private final FluxSink&lt;T&gt; fluxSink;

    private final ResultPredicate throwErrorPredicate;

    private final LdaptiveErrorHandler errorHandler;

    /**
     * Instantiates a new Flux sink aware result handler.
     *
     * @param fluxSink the flux sink
     * @param throwErrorPredicate the throw error predicate
     * @param errorHandler the error handler
     */
    public FluxSinkAwareResultHandler(
        FluxSink&lt;T&gt; fluxSink,
        ResultPredicate throwErrorPredicate,
<span class="fc" id="L381">        LdaptiveErrorHandler errorHandler) {</span>
<span class="fc" id="L382">      this.throwErrorPredicate = throwErrorPredicate;</span>
<span class="fc" id="L383">      this.errorHandler = errorHandler;</span>
<span class="fc" id="L384">      this.fluxSink = fluxSink;</span>
<span class="fc" id="L385">    }</span>

    @Override
    public void accept(Result result) {
<span class="pc bpc" id="L389" title="2 of 4 branches missed.">      if (throwErrorPredicate != null &amp;&amp; throwErrorPredicate.test(result)) {</span>
<span class="nc" id="L390">        fluxSink.error(errorHandler.map(new LdapException(result)));</span>
      } else {
<span class="fc" id="L392">        fluxSink.complete();</span>
      }
<span class="fc" id="L394">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>