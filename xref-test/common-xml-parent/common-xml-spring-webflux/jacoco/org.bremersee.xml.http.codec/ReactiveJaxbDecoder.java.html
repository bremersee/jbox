<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReactiveJaxbDecoder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Common Xml Spring WebFlux</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.xml.http.codec</a> &gt; <span class="el_source">ReactiveJaxbDecoder.java</span></div><h1>ReactiveJaxbDecoder.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2019 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.xml.http.codec;

import static java.util.Objects.isNull;

import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.UnmarshalException;
import jakarta.xml.bind.Unmarshaller;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlSchema;
import jakarta.xml.bind.annotation.XmlType;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import javax.xml.XMLConstants;
import javax.xml.namespace.QName;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.events.XMLEvent;
import org.bremersee.xml.JaxbContextBuilder;
import org.reactivestreams.Publisher;
import org.springframework.core.ResolvableType;
import org.springframework.core.codec.AbstractDecoder;
import org.springframework.core.codec.CodecException;
import org.springframework.core.codec.DecodingException;
import org.springframework.core.codec.Hints;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.core.log.LogFormatUtils;
import org.springframework.http.MediaType;
import org.springframework.http.codec.xml.XmlEventDecoder;
import org.springframework.lang.NonNull;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.MimeType;
import org.springframework.util.MimeTypeUtils;
import org.springframework.util.xml.StaxUtils;
import reactor.core.Exceptions;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.SynchronousSink;

/**
 * Decode from a bytes stream containing XML elements to a stream of {@code Object}s (POJOs).
 *
 * &lt;p&gt;The decoding parts are taken from {@link org.springframework.http.codec.xml.Jaxb2XmlDecoder}.
 *
 * @author Sebastien Deleuze
 * @author Arjen Poutsma
 * @author Christian Bremer
 */
public class ReactiveJaxbDecoder extends AbstractDecoder&lt;Object&gt; {

  /**
   * The default value for JAXB annotations.
   *
   * @see XmlRootElement#name()
   * @see XmlRootElement#namespace()
   * @see XmlType#name()
   * @see XmlType#namespace()
   */
  private static final String JAXB_DEFAULT_ANNOTATION_VALUE = &quot;##default&quot;;

<span class="fc" id="L85">  private static final XMLInputFactory inputFactory = StaxUtils.createDefensiveInputFactory();</span>

<span class="fc" id="L87">  private final XmlEventDecoder xmlEventDecoder = new XmlEventDecoder();</span>

  private final JaxbContextBuilder jaxbContextBuilder;

  private final Set&lt;Class&lt;?&gt;&gt; ignoreReadingClasses;

<span class="fc" id="L93">  private int maxInMemorySize = 256 * 1024;</span>

  /**
   * Instantiates a new reactive jaxb decoder.
   *
   * @param jaxbContextBuilder the jaxb context builder
   */
  public ReactiveJaxbDecoder(JaxbContextBuilder jaxbContextBuilder) {
<span class="fc" id="L101">    this(jaxbContextBuilder, null);</span>
<span class="fc" id="L102">  }</span>

  /**
   * Instantiates a new Reactive jaxb decoder.
   *
   * @param jaxbContextBuilder the jaxb context builder
   * @param ignoreReadingClasses the ignore reading classes
   */
  public ReactiveJaxbDecoder(
      JaxbContextBuilder jaxbContextBuilder,
      Set&lt;Class&lt;?&gt;&gt; ignoreReadingClasses) {

<span class="fc" id="L114">    super(MimeTypeUtils.APPLICATION_XML, MimeTypeUtils.TEXT_XML,</span>
        new MediaType(&quot;application&quot;, &quot;*+xml&quot;));
<span class="fc" id="L116">    Assert.notNull(jaxbContextBuilder, &quot;JaxbContextBuilder must be present.&quot;);</span>
<span class="fc" id="L117">    this.jaxbContextBuilder = jaxbContextBuilder;</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    this.ignoreReadingClasses = isNull(ignoreReadingClasses) ? Set.of() : ignoreReadingClasses;</span>
<span class="fc" id="L119">  }</span>

  /**
   * Set the max number of bytes that can be buffered by this decoder. This is either the size of
   * the entire input when decoding as a whole, or when using async parsing with Aalto XML, it is
   * the size of one top-level XML tree. When the limit is exceeded, {@link
   * org.springframework.core.io.buffer.DataBufferLimitException} is raised.
   *
   * &lt;p&gt;By default, this is set to 256K.
   *
   * @param byteCount the max number of bytes to buffer, or -1 for unlimited
   */
  public void setMaxInMemorySize(int byteCount) {
<span class="fc" id="L132">    this.maxInMemorySize = byteCount;</span>
<span class="fc" id="L133">    this.xmlEventDecoder.setMaxInMemorySize(byteCount);</span>
<span class="fc" id="L134">  }</span>

  /**
   * Return the {@link #setMaxInMemorySize configured} byte count limit.
   *
   * @return the max in memory size
   */
  public int getMaxInMemorySize() {
<span class="fc" id="L142">    return this.maxInMemorySize;</span>
  }

  @Override
  public boolean canDecode(
      @NonNull ResolvableType elementType,
      @Nullable MimeType mimeType) {

<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (super.canDecode(elementType, mimeType)) {</span>
<span class="fc" id="L151">      final Class&lt;?&gt; outputClass = elementType.getRawClass();</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">      return !ignoreReadingClasses.contains(outputClass)</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">          &amp;&amp; jaxbContextBuilder.canUnmarshal(outputClass);</span>
    } else {
<span class="fc" id="L155">      return false;</span>
    }
  }

  @NonNull
  @Override
  public Flux&lt;Object&gt; decode(
      @NonNull Publisher&lt;DataBuffer&gt; inputStream,
      ResolvableType elementType,
      @Nullable MimeType mimeType,
      @Nullable Map&lt;String, Object&gt; hints) {

<span class="nc" id="L167">    Flux&lt;XMLEvent&gt; xmlEventFlux = this.xmlEventDecoder.decode(</span>
<span class="nc" id="L168">        inputStream, ResolvableType.forClass(XMLEvent.class), mimeType, hints);</span>

<span class="nc" id="L170">    Class&lt;?&gt; outputClass = elementType.toClass();</span>
<span class="nc" id="L171">    QName typeName = toQualifiedName(outputClass);</span>
<span class="nc" id="L172">    Flux&lt;List&lt;XMLEvent&gt;&gt; splitEvents = split(xmlEventFlux, typeName);</span>

<span class="nc" id="L174">    return splitEvents.map(events -&gt; {</span>
<span class="nc" id="L175">      Object value = unmarshal(events, outputClass);</span>
<span class="nc" id="L176">      LogFormatUtils.traceDebug(logger, traceOn -&gt; {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        String formatted = LogFormatUtils.formatValue(value, !traceOn);</span>
<span class="nc" id="L178">        return Hints.getLogPrefix(hints) + &quot;Decoded [&quot; + formatted + &quot;]&quot;;</span>
      });
<span class="nc" id="L180">      return value;</span>
    });
  }

  @NonNull
  @Override
  @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;cast&quot;})
  // XMLEventReader is Iterator&lt;Object&gt; on JDK 9
  public Object decode(
      DataBuffer dataBuffer,
      ResolvableType targetType,
      @Nullable MimeType mimeType,
      @Nullable Map&lt;String, Object&gt; hints) throws DecodingException {

    try {
<span class="fc" id="L195">      Iterator eventReader = inputFactory.createXMLEventReader(dataBuffer.asInputStream());</span>
<span class="fc" id="L196">      List&lt;XMLEvent&gt; events = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L197">      eventReader.forEachRemaining(event -&gt; events.add((XMLEvent) event));</span>
<span class="fc" id="L198">      return unmarshal(events, targetType.toClass());</span>
<span class="nc" id="L199">    } catch (XMLStreamException ex) {</span>
<span class="nc" id="L200">      throw Exceptions.propagate(ex);</span>
    } finally {
<span class="fc" id="L202">      DataBufferUtils.release(dataBuffer);</span>
    }
  }

  @NonNull
  @Override
  public Mono&lt;Object&gt; decodeToMono(
      @NonNull Publisher&lt;DataBuffer&gt; input,
      @NonNull ResolvableType elementType,
      @Nullable MimeType mimeType,
      @Nullable Map&lt;String, Object&gt; hints) {

<span class="fc" id="L214">    return DataBufferUtils.join(input, this.maxInMemorySize)</span>
<span class="fc" id="L215">        .map(dataBuffer -&gt; decode(dataBuffer, elementType, mimeType, hints));</span>
  }

  private Object unmarshal(List&lt;XMLEvent&gt; events, Class&lt;?&gt; outputClass) {
    try {
<span class="fc" id="L220">      Unmarshaller unmarshaller = jaxbContextBuilder.buildUnmarshaller(outputClass);</span>
<span class="fc" id="L221">      XMLEventReader eventReader = StaxUtils.createXMLEventReader(events);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">      if (outputClass.isAnnotationPresent(XmlRootElement.class)) {</span>
<span class="fc" id="L223">        return unmarshaller.unmarshal(eventReader);</span>
      } else {
<span class="nc" id="L225">        JAXBElement&lt;?&gt; jaxbElement = unmarshaller.unmarshal(eventReader, outputClass);</span>
<span class="nc" id="L226">        return jaxbElement.getValue();</span>
      }
<span class="nc" id="L228">    } catch (UnmarshalException ex) {</span>
<span class="nc" id="L229">      throw new DecodingException(&quot;Could not unmarshal XML to &quot; + outputClass, ex);</span>
<span class="nc" id="L230">    } catch (JAXBException ex) {</span>
<span class="nc" id="L231">      throw new CodecException(&quot;Invalid JAXB configuration&quot;, ex);</span>
    }
  }

  /**
   * Returns the qualified name for the given class, according to the mapping rules in the JAXB
   * specification.
   *
   * @param outputClass the output class
   * @return the q name
   */
  QName toQualifiedName(Class&lt;?&gt; outputClass) {
    String localPart;
    String namespaceUri;

<span class="nc bnc" id="L246" title="All 2 branches missed.">    if (outputClass.isAnnotationPresent(XmlRootElement.class)) {</span>
<span class="nc" id="L247">      XmlRootElement annotation = outputClass.getAnnotation(XmlRootElement.class);</span>
<span class="nc" id="L248">      localPart = annotation.name();</span>
<span class="nc" id="L249">      namespaceUri = annotation.namespace();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">    } else if (outputClass.isAnnotationPresent(XmlType.class)) {</span>
<span class="nc" id="L251">      XmlType annotation = outputClass.getAnnotation(XmlType.class);</span>
<span class="nc" id="L252">      localPart = annotation.name();</span>
<span class="nc" id="L253">      namespaceUri = annotation.namespace();</span>
<span class="nc" id="L254">    } else {</span>
<span class="nc" id="L255">      throw new IllegalArgumentException(&quot;Output class [&quot; + outputClass.getName()</span>
          + &quot;] is neither annotated with @XmlRootElement nor @XmlType&quot;);
    }

<span class="nc bnc" id="L259" title="All 2 branches missed.">    if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(localPart)) {</span>
<span class="nc" id="L260">      localPart = ClassUtils.getShortNameAsProperty(outputClass);</span>
    }
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (JAXB_DEFAULT_ANNOTATION_VALUE.equals(namespaceUri)) {</span>
<span class="nc" id="L263">      Package outputClassPackage = outputClass.getPackage();</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">      if (outputClassPackage != null &amp;&amp; outputClassPackage.isAnnotationPresent(XmlSchema.class)) {</span>
<span class="nc" id="L265">        XmlSchema annotation = outputClassPackage.getAnnotation(XmlSchema.class);</span>
<span class="nc" id="L266">        namespaceUri = annotation.namespace();</span>
<span class="nc" id="L267">      } else {</span>
<span class="nc" id="L268">        namespaceUri = XMLConstants.NULL_NS_URI;</span>
      }
    }
<span class="nc" id="L271">    return new QName(namespaceUri, localPart);</span>
  }

  /**
   * Split a flux of {@link XMLEvent XMLEvents} into a flux of XMLEvent lists, one list for each
   * branch of the tree that starts with the given qualified name. That is, given the XMLEvents
   * shown {@linkplain XmlEventDecoder here}, and the {@code desiredName} &quot;{@code child}&quot;, this
   * method returns a flux of two lists, each of which containing the events of a particular branch
   * of the tree that starts with &quot;{@code child}&quot;.
   * &lt;ol&gt;
   * &lt;li&gt;The first list, dealing with the first branch of the tree:
   * &lt;ol&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.StartElement} {@code child}&lt;/li&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.Characters} {@code foo}&lt;/li&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.EndElement} {@code child}&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;li&gt;The second list, dealing with the second branch of the tree:
   * &lt;ol&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.StartElement} {@code child}&lt;/li&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.Characters} {@code bar}&lt;/li&gt;
   * &lt;li&gt;{@link javax.xml.stream.events.EndElement} {@code child}&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @param xmlEventFlux the xml event as flux
   * @param desiredName the desired name
   * @return the list of xml events as flux
   */
  Flux&lt;List&lt;XMLEvent&gt;&gt; split(Flux&lt;XMLEvent&gt; xmlEventFlux, QName desiredName) {
<span class="nc" id="L301">    return xmlEventFlux.handle(new SplitHandler(desiredName));</span>
  }

  private static class SplitHandler implements
      BiConsumer&lt;XMLEvent, SynchronousSink&lt;List&lt;XMLEvent&gt;&gt;&gt; {

    private final QName desiredName;

    private List&lt;XMLEvent&gt; events;

<span class="nc" id="L311">    private int elementDepth = 0;</span>

<span class="nc" id="L313">    private int barrier = Integer.MAX_VALUE;</span>

    /**
     * Instantiates a new split handler.
     *
     * @param desiredName the desired name
     */
<span class="nc" id="L320">    public SplitHandler(QName desiredName) {</span>
<span class="nc" id="L321">      this.desiredName = desiredName;</span>
<span class="nc" id="L322">    }</span>

    @Override
    public void accept(XMLEvent event, SynchronousSink&lt;List&lt;XMLEvent&gt;&gt; sink) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">      if (event.isStartElement()) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (this.barrier == Integer.MAX_VALUE) {</span>
<span class="nc" id="L328">          QName startElementName = event.asStartElement().getName();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">          if (this.desiredName.equals(startElementName)) {</span>
<span class="nc" id="L330">            this.events = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L331">            this.barrier = this.elementDepth;</span>
          }
        }
<span class="nc" id="L334">        this.elementDepth++;</span>
      }
<span class="nc bnc" id="L336" title="All 2 branches missed.">      if (this.elementDepth &gt; this.barrier) {</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        Assert.state(this.events != null, &quot;No XMLEvent List&quot;);</span>
<span class="nc" id="L338">        this.events.add(event);</span>
      }
<span class="nc bnc" id="L340" title="All 2 branches missed.">      if (event.isEndElement()) {</span>
<span class="nc" id="L341">        this.elementDepth--;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (this.elementDepth == this.barrier) {</span>
<span class="nc" id="L343">          this.barrier = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">          Assert.state(this.events != null, &quot;No XMLEvent List&quot;);</span>
<span class="nc" id="L345">          sink.next(this.events);</span>
        }
      }
<span class="nc" id="L348">    }</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>