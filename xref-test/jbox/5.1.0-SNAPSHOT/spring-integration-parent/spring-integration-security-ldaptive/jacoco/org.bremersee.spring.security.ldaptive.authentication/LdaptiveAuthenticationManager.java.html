<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LdaptiveAuthenticationManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Spring Integration Security Ldaptive</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.spring.security.ldaptive.authentication</a> &gt; <span class="el_source">LdaptiveAuthenticationManager.java</span></div><h1>LdaptiveAuthenticationManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.spring.security.ldaptive.authentication;

import static java.util.Objects.isNull;
import static java.util.Objects.nonNull;
import static java.util.Objects.requireNonNullElseGet;
import static org.springframework.util.ObjectUtils.isEmpty;

import java.util.Collection;
import java.util.Optional;
import java.util.stream.Stream;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.bremersee.ldaptive.DefaultLdaptiveErrorHandler;
import org.bremersee.ldaptive.LdaptiveTemplate;
import org.bremersee.spring.security.core.EmailToUsernameResolver;
import org.bremersee.spring.security.ldaptive.authentication.provider.NoAccountControlEvaluator;
import org.bremersee.spring.security.ldaptive.userdetails.LdaptiveRememberMeTokenProvider;
import org.bremersee.spring.security.ldaptive.userdetails.LdaptiveUserDetails;
import org.bremersee.spring.security.ldaptive.userdetails.LdaptiveUserDetailsService;
import org.ldaptive.BindOperation;
import org.ldaptive.BindResponse;
import org.ldaptive.CompareRequest;
import org.ldaptive.ConnectionConfig;
import org.ldaptive.ConnectionFactory;
import org.ldaptive.DefaultConnectionFactory;
import org.ldaptive.LdapException;
import org.ldaptive.SimpleBindRequest;
import org.ldaptive.SingleConnectionFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.support.MessageSourceAccessor;
import org.springframework.core.convert.converter.Converter;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.AccountExpiredException;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.CredentialsExpiredException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.authentication.RememberMeAuthenticationToken;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.SpringSecurityMessageSource;
import org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.util.Assert;

/**
 * The ldaptive authentication manager.
 *
 * @author Christian Bremer
 */
public class LdaptiveAuthenticationManager
    implements AuthenticationManager, AuthenticationProvider, MessageSourceAware {

  /**
   * The Logger.
   */
<span class="fc" id="L80">  protected final Log logger = LogFactory.getLog(this.getClass());</span>

  /**
   * The authentication properties.
   */
  @Getter(AccessLevel.PROTECTED)
  private final LdaptiveAuthenticationProperties authenticationProperties;

  /**
   * The remember-me key.
   */
  @Getter(AccessLevel.PROTECTED)
  private final String rememberMeKey;

  /**
   * The application ldaptive template.
   */
  @Getter(AccessLevel.PROTECTED)
  private final LdaptiveTemplate applicationLdaptiveTemplate;

  /**
   * The email to username resolver.
   */
  @Getter(AccessLevel.PROTECTED)
  private EmailToUsernameResolver emailToUsernameResolver;

  /**
   * The password encoder.
   */
  @Getter(AccessLevel.PROTECTED)
  @Setter
  private PasswordEncoder passwordEncoder;

  /**
   * The account control evaluator.
   */
  @Getter(AccessLevel.PROTECTED)
  private AccountControlEvaluator accountControlEvaluator;

  /**
   * The granted authorities mapper.
   */
  @Getter(AccessLevel.PROTECTED)
  @Setter
  private GrantedAuthoritiesMapper grantedAuthoritiesMapper;

  /**
   * The remember-me token provider.
   */
  @Getter(AccessLevel.PROTECTED)
  @Setter
  private LdaptiveRememberMeTokenProvider passwordProvider;

  /**
   * The token converter.
   */
  @Getter(AccessLevel.PROTECTED)
  @Setter
  private Converter&lt;LdaptiveUserDetails, LdaptiveAuthentication&gt; tokenConverter;

  /**
   * The message source.
   */
<span class="fc" id="L143">  @Getter(AccessLevel.PROTECTED)</span>
<span class="fc" id="L144">  private MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();</span>

  /**
   * Instantiates a new ldaptive authentication manager.
   *
   * @param connectionConfig the connection config
   * @param authenticationProperties the authentication properties
   * @param rememberMeKey the remember me key
   */
  public LdaptiveAuthenticationManager(
      ConnectionConfig connectionConfig,
      LdaptiveAuthenticationProperties authenticationProperties,
      String rememberMeKey) {
<span class="fc" id="L157">    this(new DefaultConnectionFactory(connectionConfig), authenticationProperties, rememberMeKey);</span>
<span class="fc" id="L158">  }</span>

  /**
   * Instantiates a new ldaptive authentication manager.
   *
   * @param connectionFactory the connection factory
   * @param authenticationProperties the authentication properties
   * @param rememberMeKey the remember me key
   */
  public LdaptiveAuthenticationManager(
      ConnectionFactory connectionFactory,
      LdaptiveAuthenticationProperties authenticationProperties,
      String rememberMeKey) {
<span class="fc" id="L171">    this(new LdaptiveTemplate(connectionFactory), authenticationProperties, rememberMeKey);</span>
<span class="fc" id="L172">  }</span>

  /**
   * Instantiates a new ldaptive authentication manager.
   *
   * @param applicationLdaptiveTemplate the application ldaptive template
   * @param authenticationProperties the authentication properties
   * @param rememberMeKey the remember me key
   */
  public LdaptiveAuthenticationManager(
      LdaptiveTemplate applicationLdaptiveTemplate,
      LdaptiveAuthenticationProperties authenticationProperties,
<span class="fc" id="L184">      String rememberMeKey) {</span>

<span class="fc" id="L186">    this.applicationLdaptiveTemplate = applicationLdaptiveTemplate;</span>
<span class="fc" id="L187">    Assert.notNull(getApplicationLdaptiveTemplate(), &quot;Application ldaptive template is required.&quot;);</span>
<span class="fc" id="L188">    this.authenticationProperties = authenticationProperties;</span>
<span class="fc" id="L189">    Assert.notNull(getAuthenticationProperties(), &quot;Authentication properties are required.&quot;);</span>
<span class="fc" id="L190">    this.rememberMeKey = rememberMeKey;</span>

    // emailToUsernameResolver
<span class="fc" id="L193">    setEmailToUsernameResolver(new EmailToUsernameResolverByLdapAttribute(</span>
<span class="fc" id="L194">        getAuthenticationProperties(), getApplicationLdaptiveTemplate()));</span>

    // accountControlEvaluator
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (isNull(getAuthenticationProperties().getAccountControlEvaluator())) {</span>
<span class="fc" id="L198">      setAccountControlEvaluator(new NoAccountControlEvaluator());</span>
    } else {
<span class="fc" id="L200">      setAccountControlEvaluator(getAuthenticationProperties().getAccountControlEvaluator().get());</span>
    }
<span class="fc" id="L202">  }</span>

  /**
   * Sets email to username resolver.
   *
   * @param emailToUsernameResolver the email to username resolver
   */
  public void setEmailToUsernameResolver(
      EmailToUsernameResolver emailToUsernameResolver) {
<span class="fc bfc" id="L211" title="All 2 branches covered.">    if (nonNull(emailToUsernameResolver)) {</span>
<span class="fc" id="L212">      this.emailToUsernameResolver = emailToUsernameResolver;</span>
    }
<span class="fc" id="L214">  }</span>

  /**
   * Sets account control evaluator.
   *
   * @param accountControlEvaluator the account control evaluator
   */
  public void setAccountControlEvaluator(
      AccountControlEvaluator accountControlEvaluator) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (nonNull(accountControlEvaluator)) {</span>
<span class="fc" id="L224">      this.accountControlEvaluator = accountControlEvaluator;</span>
    }
<span class="fc" id="L226">  }</span>

  @Override
  public void setMessageSource(@NonNull MessageSource messageSource) {
<span class="fc" id="L230">    this.messages = new MessageSourceAccessor(messageSource);</span>
<span class="fc" id="L231">  }</span>

  /**
   * Init.
   */
  public void init() {
<span class="fc bfc" id="L237" title="All 4 branches covered.">    if (!isSimpleBindAuthentication() &amp;&amp; isNull(getPasswordEncoder())) {</span>
<span class="fc" id="L238">      throw new IllegalStateException(String.format(&quot;A password attribute is set (%s) but no &quot;</span>
              + &quot;password encoder is present. Either delete the password attribute to perform a &quot;
              + &quot;bind to authenticate or set a password encoder.&quot;,
<span class="fc" id="L241">          getAuthenticationProperties().getPasswordAttribute()));</span>
    }
<span class="fc" id="L243">  }</span>

  @Override
  public boolean supports(Class&lt;?&gt; authentication) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication)</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        || isRememberMeAuthentication(authentication);</span>
  }

  private boolean isRememberMeAuthentication(Class&lt;?&gt; authentication) {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    return !isEmpty(getRememberMeKey())</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        &amp;&amp; RememberMeAuthenticationToken.class.isAssignableFrom(authentication);</span>
  }

  /**
   * Remember me key matches given authentication.
   *
   * @param authentication the authentication
   * @return the boolean
   */
  protected boolean rememberMeKeyMatches(RememberMeAuthenticationToken authentication) {
<span class="fc" id="L263">    return Optional.ofNullable(getRememberMeKey())</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        .filter(key -&gt; key.hashCode() == authentication.getKeyHash())</span>
<span class="fc" id="L265">        .isPresent();</span>
  }

  @Override
  public Authentication authenticate(Authentication authentication)
      throws AuthenticationException {

<span class="pc bpc" id="L272" title="1 of 2 branches missed.">    if (!supports(authentication.getClass())) {</span>
<span class="nc" id="L273">      logger.debug(String.format(&quot;Authentication [%s] is not supported.&quot;,</span>
<span class="nc" id="L274">          authentication.getClass().getName()));</span>
<span class="nc" id="L275">      return null;</span>
    }
<span class="fc bfc" id="L277" title="All 2 branches covered.">    if (authentication instanceof RememberMeAuthenticationToken rma) {</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">      if (!rememberMeKeyMatches(rma)) {</span>
<span class="fc" id="L279">        throw new BadCredentialsException(getMessages().getMessage(</span>
            &quot;RememberMeAuthenticationProvider.incorrectKey&quot;,
            &quot;The presented RememberMeAuthenticationToken does not contain the expected key&quot;));
      }
<span class="nc" id="L283">      return rma;</span>
    }

<span class="fc" id="L286">    String name = getName(authentication);</span>
<span class="fc" id="L287">    logger.debug(&quot;Authenticating user '&quot; + name + &quot;' ...&quot;);</span>
<span class="fc" id="L288">    String password = Optional.ofNullable(authentication.getCredentials())</span>
<span class="fc" id="L289">        .map(String::valueOf)</span>
<span class="pc" id="L290">        .orElseThrow(() -&gt; new BadCredentialsException(&quot;Password is required.&quot;));</span>
<span class="fc" id="L291">    String username = getEmailToUsernameResolver()</span>
<span class="fc" id="L292">        .getUsernameByEmail(name)</span>
<span class="fc" id="L293">        .orElse(name);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">    if (isRefusedUsername(username)) {</span>
<span class="fc" id="L295">      throw new DisabledException(String</span>
<span class="fc" id="L296">          .format(&quot;Username '%s' is refused by configuration.&quot;, username));</span>
    }

<span class="fc" id="L299">    LdaptiveUserDetails userDetails = getUserDetailsService().loadUserByUsername(username);</span>
<span class="fc" id="L300">    checkPassword(userDetails, password);</span>
<span class="fc" id="L301">    checkAccountControl(userDetails);</span>

<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (nonNull(getTokenConverter())) {</span>
<span class="fc" id="L304">      return getTokenConverter().convert(userDetails);</span>
    }
<span class="fc" id="L306">    return new LdaptiveAuthenticationToken(userDetails);</span>
  }

  /**
   * Determines whether the username is refused by configuration.
   *
   * @param username the username
   * @return {@code true} if the username is refused, otherwise {@code false}
   */
  protected boolean isRefusedUsername(String username) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (isEmpty(username)) {</span>
<span class="fc" id="L317">      return true;</span>
    }
<span class="fc" id="L319">    return Stream.ofNullable(getAuthenticationProperties().getRefusedUsernames())</span>
<span class="fc" id="L320">        .flatMap(Collection::stream)</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        .filter(refusedUsername -&gt; !isEmpty(refusedUsername))</span>
<span class="fc" id="L322">        .anyMatch(refusedUsername -&gt; refusedUsername.equalsIgnoreCase(username));</span>
  }

  /**
   * Gets name.
   *
   * @param authentication the authentication
   * @return the name
   */
  protected String getName(Authentication authentication) {
<span class="fc" id="L332">    Object principal = authentication.getPrincipal();</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (principal instanceof LdaptiveUserDetails ldaptiveUserDetails) {</span>
<span class="nc" id="L334">      return requireNonNullElseGet(ldaptiveUserDetails.getDn(), authentication::getName);</span>
    }
<span class="fc" id="L336">    return authentication.getName();</span>
  }

  /**
   * Gets user details service.
   *
   * @return the user details service
   */
  public LdaptiveUserDetailsService getUserDetailsService() {
<span class="fc" id="L345">    LdaptiveUserDetailsService userDetailsService = new LdaptiveUserDetailsService(</span>
<span class="fc" id="L346">        getAuthenticationProperties(), getApplicationLdaptiveTemplate());</span>
<span class="fc" id="L347">    userDetailsService.setAccountControlEvaluator(getAccountControlEvaluator());</span>
<span class="fc" id="L348">    userDetailsService.setGrantedAuthoritiesMapper(getGrantedAuthoritiesMapper());</span>
<span class="fc" id="L349">    userDetailsService.setRememberMeTokenProvider(getPasswordProvider());</span>
<span class="fc" id="L350">    return userDetailsService;</span>
  }

  /**
   * Determines whether to bind with username and password or to compare the passwords.
   *
   * @return the boolean
   */
  protected boolean isSimpleBindAuthentication() {
<span class="fc bfc" id="L359" title="All 2 branches covered.">    return isNull(getAuthenticationProperties().getPasswordAttribute())</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        || getAuthenticationProperties().getPasswordAttribute().isBlank();</span>
  }

  /**
   * Check password.
   *
   * @param user the user
   * @param password the password
   */
  protected void checkPassword(LdaptiveUserDetails user, String password) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">    if (isSimpleBindAuthentication()) {</span>
<span class="fc" id="L371">      checkPasswordWithSimpleBind(user, password);</span>
    } else {
<span class="fc" id="L373">      checkPasswordWithCompareRequest(user, password);</span>
    }
<span class="fc" id="L375">  }</span>

  protected void checkPasswordWithCompareRequest(LdaptiveUserDetails user, String password) {
<span class="fc" id="L378">    Assert.notNull(getPasswordEncoder(), &quot;No password encoder is present.&quot;);</span>
<span class="fc" id="L379">    boolean matches = getApplicationLdaptiveTemplate().compare(CompareRequest.builder()</span>
<span class="fc" id="L380">        .dn(user.getDn())</span>
<span class="fc" id="L381">        .name(getAuthenticationProperties().getPasswordAttribute())</span>
<span class="fc" id="L382">        .value(getPasswordEncoder().encode(password))</span>
<span class="fc" id="L383">        .build());</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">    if (!matches) {</span>
<span class="fc" id="L385">      throw new BadCredentialsException(&quot;Password doesn't match.&quot;);</span>
    }
<span class="fc" id="L387">  }</span>

  protected void checkPasswordWithSimpleBind(LdaptiveUserDetails user, String password) {
<span class="fc" id="L390">    SingleConnectionFactory connectionFactory = getSingleConnectionFactory();</span>
    try {
<span class="fc" id="L392">      connectionFactory.initialize();</span>
<span class="fc" id="L393">      BindOperation bind = getBindOperation(connectionFactory);</span>
<span class="fc" id="L394">      BindResponse response = bind.execute(SimpleBindRequest.builder()</span>
<span class="fc" id="L395">          .dn(user.getDn())</span>
<span class="fc" id="L396">          .password(password)</span>
<span class="fc" id="L397">          .build());</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">      if (!response.isSuccess()) {</span>
<span class="fc" id="L399">        throw new BadCredentialsException(&quot;Password doesn't match.&quot;);</span>
      }

<span class="nc" id="L402">    } catch (LdapException ldapException) {</span>
<span class="nc" id="L403">      new DefaultLdaptiveErrorHandler().handleError(ldapException);</span>
    } finally {
<span class="fc" id="L405">      connectionFactory.close();</span>
    }
<span class="fc" id="L407">  }</span>

  SingleConnectionFactory getSingleConnectionFactory() {
<span class="fc" id="L410">    ConnectionConfig connectionConfig = ConnectionConfig</span>
<span class="fc" id="L411">        .copy(getApplicationLdaptiveTemplate().getConnectionFactory().getConnectionConfig());</span>
<span class="fc" id="L412">    connectionConfig.setConnectionInitializers();</span>
<span class="fc" id="L413">    return new SingleConnectionFactory(connectionConfig);</span>
  }

  BindOperation getBindOperation(SingleConnectionFactory cf) {
<span class="fc" id="L417">    return new BindOperation(cf);</span>
  }

  /**
   * Check account control.
   *
   * @param user the user
   */
  protected void checkAccountControl(LdaptiveUserDetails user) {
<span class="fc bfc" id="L426" title="All 2 branches covered.">    if (!user.isEnabled()) {</span>
<span class="fc" id="L427">      throw new DisabledException(&quot;Account is disabled.&quot;);</span>
    }
<span class="fc bfc" id="L429" title="All 2 branches covered.">    if (!user.isAccountNonLocked()) {</span>
<span class="fc" id="L430">      throw new LockedException(&quot;Account is locked.&quot;);</span>
    }
<span class="fc bfc" id="L432" title="All 2 branches covered.">    if (!user.isAccountNonExpired()) {</span>
<span class="fc" id="L433">      throw new AccountExpiredException(&quot;Account is expired.&quot;);</span>
    }
<span class="fc bfc" id="L435" title="All 2 branches covered.">    if (!user.isCredentialsNonExpired()) {</span>
<span class="fc" id="L436">      throw new CredentialsExpiredException(&quot;Credentials are expired.&quot;);</span>
    }
<span class="fc" id="L438">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>